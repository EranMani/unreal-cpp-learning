# This file will contain information during learning process

Auto posses player
	* To let unreal possess/use our own character instead of the default one, go to:
		- actor blueprint > search for 'auto' > select player0 at auto possess player option
		
Compiles and editors
	[Glossary]
	- source code: human readable code (like c++ or blueprint)
	- binary executable: machine readable code
	- compiler: translates from human (source) to machine (binary)
	- source code editor: makes writing code fun
	
	* unreal ecosystem - the editor is a piece of software and is one that has already been compiled for us, we already have the executable for that editor.
					     The editor allows to modify and create the game project using various game assets, like meshes and blueprints.
					     We can then run the game in a separate standalone executable where it just playes the game
						 editor -> game assets -> game
						 
						 C++ is the bedrock of the editor, and once we change c++ in the editor we need to rebuild the editor binary executable.
						 source code editor -> source code -> compiler
						 
						 The compiler will take the source code, the libraries and functionality already built into unreal - will compile these together,
						 turn them into binary or output. Either an editor that we can open up and edit the game assets, or it will output a game which
						 will take the game assets and allow the player to just play the game
						 
						 Compiler will use the software Visual Studio
						 Source code will use the software Visual Studio Code
						 
C++ class
	* To create a new class, go to Tools -> new c++ class -> select between various options -> select its name -> create
	* Once done, it will open the visual studio code
	* To recompile the editor binary (make sure to close unreal editor first), go to Terminal -> Run build task -> select task projectnameEditor win64 development build
	
Unreal C++
	* Live coding - a way to compile new code fast, within the editor.
					Its button can be found in the viewport lower right point, an icon of fading cubes. Press that and the recompile will begin
					Live coding have some bugs, mostly in the area where you compile new variables, override their values, closing and opening the editor-
						will make the variable disappear. Simply restart the editor, or compile using vscode
	* BeginPlay() - whatever is written in the function, will be executed as soon as the game starts playing
	* FVector - a variable type for vectors
	* A suffix - the variable is of actor type
	* F suffix - the variable is of struct type
	* You can create a blueprint child classes from a C++ classes
	* In order to print output log messages, you need to use the following:
		UE_LOG(LogTemp, Display, TEXT("message"));
		LogTemp = the type of log category
		Display = the level of the log, how urgent it is // https://docs.unrealengine.com/4.27/en-US/API/Runtime/Core/Logging/ELogVerbosity__Type/
		TEXT = a function to tell what message to print // https://cplusplus.com/reference/cstdio/printf/
	* [SHORTCUT] to open output log, press ~ key twice
	[Functions]
	- SetActorLocation()
	- SetActorScale3D()
	- GetActorLocation()
	- FVector::Dist() - get the distance between 2 vectors
	- FVector(instance).GetSafeNormal() - get the normal of the vector
		(member function, instead of a member variable)
	- MovedUpdatedComponent(blueprint class), from character movement component - moves the updated component by the given delta, and sets the rotation
		to new rotation.
		sweep: should look out for any collisions along the way
	- GetLastUpdateRotation(blueprint class), from character movement component - get the last frame of rotation value
	

Play from here (when clicking RMB button)
	* Allows to spawn the player in the mouse pointed location
	* Used for level testing, to test different parts of the level
	* For this to work, you need to declare the player blueprint as the default pawn option in game mode blueprint, and set the level or project
	  to that game mode.
Game mode
	* an actor that controls the "rules". It tells the game how to do things such as who should spawn where, what class were going to use
	  for the player, as well as many other classes that define how a game works.
	* Can be set for the whole project, or a specific level
	
	
C++
	* header (file.h) - a file to add variables and functions. For configuring and declaring what things are in the class
	* c++ (file.cpp) - the coding itself (like blueprint eventgraph) will happen in this file. Where the actual code lives.
	* the class name will have the prefix A, which means actor (for example AMovingPlatform)
	* How to write a variable? -> int32 MyInt = 99; -- bool ShouldPlay = true;
	* Double check your capitalization and the semicolons
	* How to make a variable visible in the blueprint editor?
		UPROPERTY - add UPROPERTY(EditAnywhere), above the variable line
		UPROPERTY(EditAnywhere, Category="Something") - you can also declare a category for the variable to be visible in the editor
		UPROPERTY(VisibleAnywhere) - expose the variable in editor but it does not allow us to edit it
	* If you override the default values of the variables in the editor, then it will override everything done in C++
	* When using a struct, we need to use the constructor. The constructor will always have the same name as the data type
	[Glossary]
	- constructor: makes a new struct or class value
	- operator: symbols that do something
	- dot operator: gets something from within a struct or class
	- expression: fragment of code that produces a value
	- statement: an action to be performed (like calling a function)
	- Scope resolution operator (::) - allows to look inside a class, in the same way as the DOT operator allows to look inside an instance of class
		AMovingPlatform::Tick -> this is the tick that belongs to the moving platform class
		CurrentLocation.X -> this is the X that belongs to the current location, which is an instance of an FVector. But we can use this to get hold 
							 of functions that belong to the FVector class, and dont run on a particular instance of that class
	
Game loop
	* The game engine will take the input from the player
	* The input information will be used to update the game state
	* Render it to the display
	[Glossary]
	- frame: a single picture in a video
	- frame rate: how many frames per second (FPS)
	- tick: called every frame. Help us to update the state of the game every single frame
	- deltaTime: unreal can tell us how long each frame took to execute.
				 When multiply something by DeltaTime, it makes hte game "frame rate independent". The game will behave the same on fast and slow
				 computers
	
Scope
	* How long does the variable live?
	* Variables of a class instance lives as long as the class does
	* In a function, the variable is valid between curly braces
	* You can always know what value is going to be in a local variable, unlike a class variable which can be updated any time from any other function