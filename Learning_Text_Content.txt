# This file will contain information during learning process

Light Types
	* Directional light - used as a sun light, goes into a single direction
	* Point light - a point source of light
	* Spot light - useful for trying to illuminate a specific area or a specific object
	* Rect light - light is emanating from the entirety of the rectangle shape. This would work with office lighting or anything where you want to illuminate
				   from a larger area rather than from a particular point
	* Sky light - the light is coming from all directions. 
				  You need to create a large sphere that will envelop the whole scene, and sky light will use that sphere properties to capture scene
				  light color.
				  [NOTE] You can grab one of those spheres from the hidden engine folder
				  
	* A useful combination of light will be to the sky light(with the sky sphere object) + directional light.
	  In the sky sphere blueprint, you can link the directional light and use it to change the properties of the sky sphere.
	  By linking those two (sky sphere + directional light) in together, the sky sphere should match the angle of this directional light. 
	  [NOTE] Once you change the directional light, you should check the 'refresh material' property in the sky sphere blueprint
	  
Lights
	* Lumen - a real time global illumination light engine
	* Lumen works best when lights mobility setting is set to moveable
	
Variable addresses
	* We store all of our variables in memory
	* Variables require memory to store their data
	* The bigger the struct or classes you have will encompass a lot of data that might require even a few kb of memory per actor
	* This memory has to live somewhere, and that location is known as an address. An actor needs to have a certain location within this large field
	  of 0 and 1, and it is allocated to store the data in the actor
	* Pointers - instead of storing the entirety of an actor data variable to another one, we can create an actor pointer that doesnt store the whole
				 actor, it just stores the address where you can find an actor. This uses a lot less memory to store an address.
				 AActor MyActor = ..; ---> [CPP]AActor MyActor = ..;
				 AActor Pointer YourActor; ---> [CPP]AActor* YourActor;
				 YourActor = AddressOf(MyActor); ---> [CPP]YourActor = &MyActor;
				 
				 AActor* - this is an actor pointer, the address of an actor being stored
				 &MyActor - get the address of a variable
				 
				 This ends up pointing to the original actor, rather than copying the data over, hence the name POINTER
				 
Unreal
	* Scene component - a component that has a transform and can be attached to other components
	* Line trace - create a line (like raycast), which returns either all of the objects that the line intersected with on its path to the end, or you can
				   just get the first object that it hit
	* Shape trace (sphere trace) - sweep a sphere through the world to the end point. If it intersected with anything along the way, then that is something 
								   that the trace will hit.
								   By using a sphere trace, you will get more accurate hit results because you can expand its radius
	* Trace channel - creates a list of objects that can respond to the trace and others might want to ignore it entirely
		How to add a custom trace channel? -- go to project settings -> collisions -> trace channels -> new trace channel
	* Collisions:
		- you can enable a custom preset to get more control
		- when enabling collision:
			1) query - things like line traces and sphere trace and sweeps, etc
			2) physics - the simulation of physics and whether it bounces off other objects
		- types of collision responses:
			1) ignore - this physics body will ignore the interaction
			2) overlap - create an overlap event
			3) block - create an hit event
	
C++
	* Inheritance VS Composition - 
		inheritance: when a child class inherits from a parent calss, the child acquires all behaviors from the parent. Inheritance will make a class
					 hierarchy
					 Person ---  -> Student
							|--  -> Employee
		composition: in contrast to inheritance, it enables the creation of complex types by combining objects (components) of other types, rather
					 than inheriting from a base or parent class. A composition contains instances of other classes that implement the desired functionality
					 You can imagine a composition as playting with legos, while components are the lego bricks
		The main difference between them is in the relationship between objects: Is-a VS Has-a
		They are different in purpose too -
			inheritance: used to design a class on what it is
			composition: to design a class on what it does
	
	[Glossary]
	* Inheritance: a child class automatically has all the functionality of the parent. The child "is a" parent
	* Composition: class A has an instance of class B. It can choose to use its functionality but doesnt have to, it can just choose to take the
				   bits it wants. Class A "has a" Class B
				   
Unreal C++
	* Actor component - you can add a c++ component to objects
	* The component is OWNED by the actor. If we want a component to talk to our actor, to get its location and other things, we need to be able to
	  get a pointer to that actor. We dont want to take a copy of it.
	* You cant get data from a pointer itself. 
		float MyFloat = 5;
		float* YourFloat = &MyFloat;
		float FloatVlaue = *YourFloat
		
		By using the '*' in front of a pointer, you can get the value at this location
	* Dereferencing - to get the data from a pointer of an actor, its pointer needs to dereferenced 
		AActor* Owner = GetOwner();
		FString Name = (*Owner).GetActorNameOrLabel();
		UE_LOG(LogTemp, Display, TEXT("Mover Owner: %s"), *Name)
		
	* Another way to make the dereferncing more compact, is to use the arrow sign
		AActor* Owner = GetOwner();
		FString Name = Owner->GetActorNameOrLabel();
		
	* Use the arrow sign if you got a pointer
	  Use the dot operator if you are using a struct like FString or FVector
	  
	[EXAMPLE]
	AActor* Owner = GetOwner();
	FString OwnerName = Owner->GetActorNameOrLabel();
	FVector OwnerLocation = Owner->GetActorLocation();
	FString OwnerLocationString = OwnerLocation.ToCompactString();
	UE_LOG(LogTemp, Display, TEXT("Mover Owner %s at location: %s"), *OwnerName, *OwnerLocationString);
		
	[NOTE] DO NOT(!) STORE A COPY OF AN ACTOR DATA INTO A VARIABLE. USE POINTER INSTEAD TO BE MORE EFFICIENT
	[Functions]
	* GetOwner(): a function of an actor component which allows to get an owner pointer
	* GetActorNameOrLabel(): return the name of the actor as a string
	* VInterpConstantTo() - interpolates a vector from current to target with constant step
	* GetComponentRotation()
	* GetComponentLocation()
	* GetWorld()	
	* GetForwardVector()
	* DrawDebugLine()
	
	[C++ Compilation steps]
	* Start with the code -> C++ files, header files, etc. These get fed into a tool called the UNREAL HEADER TOOL
	* This tool is responsible for taking all the unreal specific pieces of syntax, and using them to generate more C++ code.
	  It converts all of its Unreal specific stuff (UProperty, UClass), into actual C++
	* Once it got the actual C++, it can be fed into a standard C++ compilation process, which takes 3 steps:
		1) Deal with the preprocessing step. It actually only deals with lines that start with a hash (#include)
		2) Compiler - it takes a code and converts it into executable binary, but it doesnt quite complete the step because it only does it on individual
		   C++, known as translation units, basically C++ files.
		   It takes a C++ file and translates that into binary individually, each individual C++ file
		3) Linker - brings all of that together and outputs a single executable that we can actually run
	
	* Why do we have such a complicated process?
		- The idea is that it speeds up our compilation time because, if you only make a change in a certain file, you dont need to run the entirety
		  compliation process. All you have to do is run the bits involving the file
		  
	[EXAMPLE]
	game.cpp (#include "math.h", void MyGame() {Add(1,1);})
	math.h (int Add(int A, int B);)
	math.cpp (int Add(int A, int B) {return A + B;})
	
	PREPROCESSESOR STEP - deals with any preprocesser directives, which are things that begin with a hash - > #include "math.h"
		- it takes the game.cpp and the math.h, and combines them together to create a new output file called game.i (game.include). This will include the
		  definition from math.h.
		  So now the game.i got a definition for the ADD operation.
		- run the preprocessor step on math.cpp will not change anything because this file doesnt have any preprocessor directives
		
	COMPILATION STEP  
		- it takes that C++ in each individual file and converts it into binary, but its not complete binary because for example game.cpp
		  doesnt actually know how to implement ADD, it just knows the shape of that function. This will be filled by the linker
		
	LINKER STEP 
		- takes the binary created for the game.obj file, and the binary created for the math file and bring them together to make a game.
		- it will combine the binary for both files, and finally is a complete executable that we can run, because its got the definition for everything
		  it needs
		  
	[NOTE] The 'include' line allows us to copy in the definitions from a particular file
		#include math
		
	* ULevel
		- a collection of the actors that we should bring into the UWorld
		- you may load in multiple levels into a single world. That is because often we have these streaming levels, a very large levels where we
		  dont want to load everything, every actor into the level in one go for performance reasons. So we split it up into multiple levels and that
		  allows to bring in only parts of the scene as they are required
		
	* UWorld
		- the type/class for basically the environment that we see when we play a game
		- the world is the top level object representing a map or a sandbox, in which actors and components will exist and can be rendered
		- it allows us to do line tracing. We can use a line trace by channel or line trace multi channel, which allows us to get hold of that
		  first object hit or all of the objects hit by a line trace
		- on every component and every actor, there is a function called GetWorld() which returns a POINTER to an object of type UWorld
	