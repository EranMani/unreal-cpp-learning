# This file will contain information during learning process

Light Types
	* Directional light - used as a sun light, goes into a single direction
	* Point light - a point source of light
	* Spot light - useful for trying to illuminate a specific area or a specific object
	* Rect light - light is emanating from the entirety of the rectangle shape. This would work with office lighting or anything where you want to illuminate
				   from a larger area rather than from a particular point
	* Sky light - the light is coming from all directions. 
				  You need to create a large sphere that will envelop the whole scene, and sky light will use that sphere properties to capture scene
				  light color.
				  [NOTE] You can grab one of those spheres from the hidden engine folder
				  
	* A useful combination of light will be to the sky light(with the sky sphere object) + directional light.
	  In the sky sphere blueprint, you can link the directional light and use it to change the properties of the sky sphere.
	  By linking those two (sky sphere + directional light) in together, the sky sphere should match the angle of this directional light. 
	  [NOTE] Once you change the directional light, you should check the 'refresh material' property in the sky sphere blueprint
	  
Lights
	* Lumen - a real time global illumination light engine
	* Lumen works best when lights mobility setting is set to moveable
	
Variable addresses
	* We store all of our variables in memory
	* Variables require memory to store their data
	* The bigger the struct or classes you have will encompass a lot of data that might require even a few kb of memory per actor
	* This memory has to live somewhere, and that location is known as an address. An actor needs to have a certain location within this large field
	  of 0 and 1, and it is allocated to store the data in the actor
	* Pointers - instead of storing the entirety of an actor data variable to another one, we can create an actor pointer that doesnt store the whole
				 actor, it just stores the address where you can find an actor. This uses a lot less memory to store an address.
				 AActor MyActor = ..; ---> [CPP]AActor MyActor = ..;
				 AActor Pointer YourActor; ---> [CPP]AActor* YourActor;
				 YourActor = AddressOf(MyActor); ---> [CPP]YourActor = &MyActor;
				 
				 AActor* - this is an actor pointer, the address of an actor being stored
				 &MyActor - get the address of a variable
				 
				 This ends up pointing to the original actor, rather than copying the data over, hence the name POINTER
				 
Unreal
	* Scene component - a component that has a transform and can be attached to other components
	* Line trace - create a line (like raycast), which returns either all of the objects that the line intersected with on its path to the end, or you can
				   just get the first object that it hit
	* Shape trace (sphere trace) - sweep a sphere through the world to the end point. If it intersected with anything along the way, then that is something 
								   that the trace will hit.
								   By using a sphere trace, you will get more accurate hit results because you can expand its radius
	* Trace channel - creates a list of objects that can respond to the trace and others might want to ignore it entirely
		How to add a custom trace channel? -- go to project settings -> collisions -> trace channels -> new trace channel
	* Collisions:
		- you can enable a custom preset to get more control
		- when enabling collision:
			1) query - things like line traces and sphere trace and sweeps, etc
			2) physics - the simulation of physics and whether it bounces off other objects
		- types of collision responses:
			1) ignore - this physics body will ignore the interaction
			2) overlap - create an overlap event
			3) block - create an hit event
	
C++
	* Inheritance VS Composition - 
		inheritance: when a child class inherits from a parent calss, the child acquires all behaviors from the parent. Inheritance will make a class
					 hierarchy
					 Person ---  -> Student
							|--  -> Employee
		composition: in contrast to inheritance, it enables the creation of complex types by combining objects (components) of other types, rather
					 than inheriting from a base or parent class. A composition contains instances of other classes that implement the desired functionality
					 You can imagine a composition as playting with legos, while components are the lego bricks
		The main difference between them is in the relationship between objects: Is-a VS Has-a
		They are different in purpose too -
			inheritance: used to design a class on what it is
			composition: to design a class on what it does
	
	* Pointers VS references 
		- just a memory address. They both store a reference to where another variable can be found
		- difference come down to whether they can be resassigned, can they point to a different address after they have first been created?
			pointer: YES. you can change a pointer to point to a new memory address (a new actor, component)
			reference: NO. can only be setup once when you first create it to point to another variable. It cant then be changed again
					   This is a safety feature because repointing variables can lead to problems where those variables might disappear or
					   where you set that pointer to null
		- null pointer is a pointer that points to nothing, and trying to do stuff with a pointer that sets to nothing can actually crash the engine
		- with references because you have to give them a value when you first create them, they cant be null so you cannot get these null pointer crashes
		- to access a content of a pointer you have to use some special syntax : *ActorPtr. You have to use this star in front of the pointer to make sure
		  you are getting the value in the pointer, not the memory address. With references because you never really need to get hold of the memory address,
		  you can just use the variable as if it was the variable its pointing to. You dont have to use any special syntax
		- with pointers you get hold of the address automatically. When you use the variable with a reference, you have to use a special syntax to do that.
		  you have to use '&' and it will get you basically the same address as the original variable
		- you can assign the address and use the address of '&' to do that. With reference this isnt allowed, so there is no syntax to it
		- If you want to change the actual value that were pointing to (not the address), you got again to use some special syntax. You have to put that
		  star and then assign something so the actor pointer you assign to the star actor pointer.
		  With references because you cant change the actual adress, you dont need any extra syntax
		- Examples
			float Damage = 0;   [dont have to take the address. It automatically knows that this is a reference and this is a variable]
			float& DamageRef = Damage [dont have to create a copy of the original Damage value]
			[float&] -> the '&' means it is a reference to a float, not a new float itself
			
			The two variables are pointing to the same piece of memory. They are the same variable, but with different names.
			This has the benefit of not needing a copy, just like a pointer, but it also has a lot more benefits because it is much easier to use
		
		- [NOTE] AS LONG AS WE DONT NEED TO REPOINT ANYTHING, USING REFERENCES IS GENERALLY PREFERABLE
			
		
									POINTERS          |    REFERENCES
		-- ACCESING CONTENTS       *ActorPtr                ActorRef
		-- ACCESING ADDRESS         ActorPtr               &ActorRef
		-- CHANGING THE ADDRESS    ActorPtr = &Actor        NOT ALLOWED
		-- CHANGING THE VALUE      *ActorPtr = Actor       ActorRef = Actor
	
		* The & VS * symbols in context
			[EXAMPLE 1]
			- CopyActor = *ActorPtr;
			- ActorAddress = &Actor;
			
			- symbol '*' means were getting the contents at actor pointer
			- symbol '&' means getting the address of that variable. Its getting the address of the actor or the address pointed to by the reference
			
			[EXAMPLE 2]
			- UActor* ActorPtr;
			- UActor& ActorRef;
			
			- symbol '*' means that this is a pointer to a UActor
			- symbol '&' means that this is a reference to a UActor
			
		* The real place that references shine is in parameters to functions. Every time you create a parameter (float DeltaTime), you are taking able
		  copy of that original float and passing it into the function.
		  Instead of doing that, what we might want to do is take a reference to it and pass that in instead.
		  You pass a reference variable, its address to the function, so when you access it you are actually accessing the original piece of memory and
		  not an empty copy.
		  If you change that reference parameter inside the function, it will affect the original variable as well
		  [NOTE] IF YOU USE THE KEYWORD 'CONST' BEFORE THE REFERENCE, IT WONT LET YOU CHANGE THE CONTENT OF THAT REFERENCE VARIABLE.
				 YOU CAN ONLY USE IT, READ IT, SEE WHAT IS IN THERE
		  [NOTE] if we are trying to pass a variable in, in an efficient way where we dont want to take a copy, then we will always use the 'const'
				 keyword as well as using a reference, because this prevents us from accidentally changing that variable content
		  [NOTE] if you see any parameters that are a reference but arent marked as const, then you can pretty much assume that somebody intended to use 
				 that as an out parameter
		  [NOTE] if you see a variable declared and not given a value and instantly passed into a function, you can expect the function to put
				 the value in for you
				 Out parameters are mainly about 'returning' multiple values from a function
				 
		   EXAMPLE:
				void PrintDamage(const float& Damage);
				bool HasDamage(float& OutDamage); --> The use of keyword 'Out' means its an output parameter
	
	[Glossary]
	* Inheritance: a child class automatically has all the functionality of the parent. The child "is a" parent
	* Composition: class A has an instance of class B. It can choose to use its functionality but doesnt have to, it can just choose to take the
				   bits it wants. Class A "has a" Class B
				   
Unreal C++
	* Actor component - you can add a c++ component to objects
	* The component is OWNED by the actor. If we want a component to talk to our actor, to get its location and other things, we need to be able to
	  get a pointer to that actor. We dont want to take a copy of it.
	* You cant get data from a pointer itself. 
		float MyFloat = 5;
		float* YourFloat = &MyFloat;
		float FloatVlaue = *YourFloat
		
		By using the '*' in front of a pointer, you can get the value at this location
	* Dereferencing - to get the data from a pointer of an actor, its pointer needs to dereferenced 
		AActor* Owner = GetOwner();
		FString Name = (*Owner).GetActorNameOrLabel();
		UE_LOG(LogTemp, Display, TEXT("Mover Owner: %s"), *Name)
		
	* Another way to make the dereferncing more compact, is to use the arrow sign
		AActor* Owner = GetOwner();
		FString Name = Owner->GetActorNameOrLabel();
		
	* Use the arrow sign if you got a pointer
	  Use the dot operator if you are using a struct like FString or FVector
	  
	[EXAMPLE]
	AActor* Owner = GetOwner();
	FString OwnerName = Owner->GetActorNameOrLabel();
	FVector OwnerLocation = Owner->GetActorLocation();
	FString OwnerLocationString = OwnerLocation.ToCompactString();
	UE_LOG(LogTemp, Display, TEXT("Mover Owner %s at location: %s"), *OwnerName, *OwnerLocationString);
		
	[NOTE] DO NOT(!) STORE A COPY OF AN ACTOR DATA INTO A VARIABLE. USE POINTER INSTEAD TO BE MORE EFFICIENT
	[Functions]
	* GetOwner(): a function of an actor component which allows to get an owner pointer
	* GetActorNameOrLabel(): return the name of the actor as a string
	* VInterpConstantTo() - interpolates a vector from current to target with constant step
	* GetComponentRotation()
	* GetComponentLocation()
	* GetWorld()	
	* GetForwardVector()
	* DrawDebugLine()
	* SweepSingleByChannel()
	* DrawDebugSphere()
	
	[C++ Compilation steps]
	* Start with the code -> C++ files, header files, etc. These get fed into a tool called the UNREAL HEADER TOOL
	* This tool is responsible for taking all the unreal specific pieces of syntax, and using them to generate more C++ code.
	  It converts all of its Unreal specific stuff (UProperty, UClass), into actual C++
	* Once it got the actual C++, it can be fed into a standard C++ compilation process, which takes 3 steps:
		1) Deal with the preprocessing step. It actually only deals with lines that start with a hash (#include)
		2) Compiler - it takes a code and converts it into executable binary, but it doesnt quite complete the step because it only does it on individual
		   C++, known as translation units, basically C++ files.
		   It takes a C++ file and translates that into binary individually, each individual C++ file
		3) Linker - brings all of that together and outputs a single executable that we can actually run
	
	* Why do we have such a complicated process?
		- The idea is that it speeds up our compilation time because, if you only make a change in a certain file, you dont need to run the entirety
		  compliation process. All you have to do is run the bits involving the file
		  
	[EXAMPLE]
	game.cpp (#include "math.h", void MyGame() {Add(1,1);})
	math.h (int Add(int A, int B);)
	math.cpp (int Add(int A, int B) {return A + B;})
	
	PREPROCESSESOR STEP - deals with any preprocesser directives, which are things that begin with a hash - > #include "math.h"
		- it takes the game.cpp and the math.h, and combines them together to create a new output file called game.i (game.include). This will include the
		  definition from math.h.
		  So now the game.i got a definition for the ADD operation.
		- run the preprocessor step on math.cpp will not change anything because this file doesnt have any preprocessor directives
		
	COMPILATION STEP  
		- it takes that C++ in each individual file and converts it into binary, but its not complete binary because for example game.cpp
		  doesnt actually know how to implement ADD, it just knows the shape of that function. This will be filled by the linker
		
	LINKER STEP 
		- takes the binary created for the game.obj file, and the binary created for the math file and bring them together to make a game.
		- it will combine the binary for both files, and finally is a complete executable that we can run, because its got the definition for everything
		  it needs
		  
	[NOTE] The 'include' line allows us to copy in the definitions from a particular file
		#include math
		
	* Null pointer
		- how to create a null pointer? use the keyword: nullptr
		
	* ULevel
		- a collection of the actors that we should bring into the UWorld
		- you may load in multiple levels into a single world. That is because often we have these streaming levels, a very large levels where we
		  dont want to load everything, every actor into the level in one go for performance reasons. So we split it up into multiple levels and that
		  allows to bring in only parts of the scene as they are required
		
	* UWorld
		- the type/class for basically the environment that we see when we play a game
		- the world is the top level object representing a map or a sandbox, in which actors and components will exist and can be rendered
		- it allows us to do line tracing. We can use a line trace by channel or line trace multi channel, which allows us to get hold of that
		  first object hit or all of the objects hit by a line trace
		- on every component and every actor, there is a function called GetWorld() which returns a POINTER to an object of type UWorld
		
	* FQuat::Identity - basically means that this is a no rotation
	
	* FCollisionShape::MakeSphere - create a collision in a sphere shape, with a given radius value
	
	[NOTE] IN ORDER FOR A SWEEP TO WORK, THE OBJECT THAT YOU WANT TO FIND MUST PUT THE COLLISION RESPONSE OF THE COLLISION TYPE TO BLOCK, NOT IGNORE
	
	* Expose a function from a c++ class into a blueprint - 
		UPROPERTY - for exposing variables
		UFUNCTION - for exposing functions
		BLUEPRINT CALLABLE - this function now becomes a node that blueprint has access to
		
	* Physics
		- In order to grab hold of an object, we need to interact with the physics system. There is a component we can use called - physics handle,
		  which allows to grab physical objects and tell them where we want to be in the world, in a way that it acknowledges physical constraints
		  so it doesnt pass through walls
		  [COMPONENT] Physics handle
		  [FUNCTION] FindComponentByClass<Type>() - a template function, means that you can pass it some parameters that actually get evaluated when
													you compile. This function returns a pointer to the type you added between brackets
		  compile time arguments: <>
		  runtime arguments: ()
		  [NOTE] When you try to use the arrow operator or dereferncing operator on a null pointer, it will crash the engine
		  